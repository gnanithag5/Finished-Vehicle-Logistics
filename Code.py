# -*- coding: utf-8 -*-
"""IoT Final Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FmYUbti_lA7-isNFdCNgyo0_B9s3qT3E
"""

import uuid
import random
import datetime
import pytz

def generate_rfid():
    return str(uuid.uuid4())

def generate_timestamp(timezone='MST'):
    tz = pytz.timezone(timezone)
    return datetime.datetime.now(tz).strftime("%Y-%m-%d %H:%M:%S %Z%z")

def assign_parking_space():
    # Assuming there are 500 parking spaces with IDs from 1 to 500
    return random.randint(1, 500)

def simulate_rfid_readings(num_readings, timezone='MST'):
    readings = []
    for _ in range(num_readings):
        tag_id = generate_rfid()
        timestamp = generate_timestamp(timezone)
        manufacturing_date = '2024-05-01'
        Status = 'Enter'
        readings.append({'tag_id': tag_id, 'timestamp': timestamp, 'manufactured_date': manufacturing_date, 'status': Status,})
    return readings

num_readings = 3
timezone = 'America/Denver'
simulated_readings = simulate_rfid_readings(num_readings, timezone)

for reading in simulated_readings:
    print(reading)

import numpy as np
import math

def generate_timestamp(timezone='MST'):
    tz = pytz.timezone(timezone)
    return datetime.datetime.now(tz).strftime("%Y-%m-%d %H:%M:%S %Z%z")

# Function to calculate tag location from DOA
def calculate_tag_location(doa_degrees):
    # Convert DOA to radians
    theta = np.deg2rad(doa_degrees)  # Convert DOA from degrees to radians

    # Define warehouse dimensions
    warehouse_width = 120  # Width of the warehouse in meters
    warehouse_height = 60  # Height of the warehouse in meters

    # Define antenna layout parameters
    horizontal_spacing = 15  # Horizontal spacing between antennas in meters
    vertical_spacing = 20    # Vertical spacing between antennas in meters
    antenna_height = 30      # Height of antennas above ground level in meters

    # Calculate horizontal and vertical angles
    alpha = math.atan(horizontal_spacing / (2 * antenna_height * math.tan(theta)))  # Horizontal angle in radians
    beta = math.atan(vertical_spacing / (2 * antenna_height * math.tan(theta)))      # Vertical angle in radians

    # Calculate Cartesian coordinates (x, y)
    x = horizontal_spacing / (2 * math.tan(alpha))  # Horizontal distance in meters
    y = vertical_spacing / (2 * math.tan(beta))    # Vertical distance in meters

    # Adjust coordinates to fit within warehouse dimensions
    x = min(max(x, 0), warehouse_width)    # Ensure x-coordinate is within [0, warehouse_width]
    y = min(max(y, 0), warehouse_height)   # Ensure y-coordinate is within [0, warehouse_height]

    return x, y

# Generate a random DOA value within a certain range of degrees
min_doa_degrees = 0   # Minimum DOA value in degrees
max_doa_degrees = 180 # Maximum DOA value in degrees
random_doa_degrees = np.random.uniform(min_doa_degrees, max_doa_degrees)

# Calculate tag location from random DOA
tag_location = calculate_tag_location(random_doa_degrees)

print("Random DOA value:", random_doa_degrees)
print("Estimated tag location (x, y):", tag_location)

import random
import pandas as pd
import matplotlib.pyplot as plt

class ParkingLot:
    def __init__(self, total_spaces):
        self.total_spaces = total_spaces
        self.available_spaces = total_spaces
        self.parking_map = [""] * total_spaces  # Use strings instead of integers
        self.parking_table = pd.DataFrame(columns=["Car ID", "Parking Space"])

    def assign_parking_space(self, car_id):
        empty_spaces = [i for i, space in enumerate(self.parking_map) if space == ""]
        if not empty_spaces:
            print("Parking lot is full.")
            return -1
        else:
            parking_space = random.choice(empty_spaces)
            self.parking_map[parking_space] = car_id
            self.available_spaces -= 1
            self.parking_table.loc[len(self.parking_table)] = [car_id, parking_space]
            return parking_space

    def print_layout(self):
        rows = 10
        cols = self.total_spaces // rows
        occupancy_grid = [[1 if car_id else 0 for car_id in self.parking_map[i*cols:(i+1)*cols]] for i in range(rows)]

        plt.figure(figsize=(15, 5))
        plt.imshow(occupancy_grid, cmap='binary', aspect='auto')
        plt.title('Parking Lot Layout')
        plt.xlabel('Parking Space')
        plt.ylabel('Row')
        plt.yticks(range(rows), [f"Row {i+1}" for i in range(rows)])
        plt.colorbar(label='Occupancy')
        plt.show()

def main():
    parking_lot = ParkingLot(500)

    while True:
        car_id = input("Enter car ID (type 'exit' to quit): ")
        if car_id.lower() == 'exit':
            break

        parking_space = parking_lot.assign_parking_space(car_id)

        if parking_space != -1:
            print(f"Car {car_id} parked at space {parking_space}")
        else:
            print("Parking failed.")

    parking_lot.print_layout()
    print("\nParking Table:")
    print(parking_lot.parking_table)

if __name__ == "__main__":
    main()

import numpy as np
import math
import random
from datetime import datetime
import pytz

# Define constants
warehouse_width = 120  # Width of the warehouse in meters
warehouse_height = 60  # Height of the warehouse in meters
sensor_rows = 8  # Number of sensor rows
sensor_cols = 3  # Number of sensor columns
sensor_height = 10  # Height of sensors above ground level in meters
sensor_spacing_x = warehouse_width / sensor_cols  # Horizontal spacing between sensors
sensor_spacing_y = warehouse_height / sensor_rows  # Vertical spacing between sensors
sensor_radius = 7.5  # Sensing range of sensors in meters

# Function to calculate tag location from DOA
def calculate_tag_location(doa):
    # Convert DOA to radians
    theta = np.deg2rad(doa)  # Convert DOA from degrees to radians

    # Randomly select a sensor section
    section = random.randint(1, sensor_rows * sensor_cols)

    # Calculate sensor coordinates
    sensor_row = (section - 1) // sensor_cols
    sensor_col = (section - 1) % sensor_cols
    sensor_x = (sensor_col * sensor_spacing_x) + (sensor_spacing_x / 2)
    sensor_y = (sensor_row * sensor_spacing_y) + (sensor_spacing_y / 2)

    # Calculate horizontal and vertical angles
    alpha = math.atan(sensor_x / sensor_height)  # Horizontal angle in radians
    beta = math.atan(sensor_y / sensor_height)   # Vertical angle in radians

    # Calculate Cartesian coordinates (x, y)
    x = sensor_x + sensor_radius * math.tan(alpha) * math.cos(theta)  # Horizontal distance in meters
    y = sensor_y + sensor_radius * math.tan(beta) * math.sin(theta)    # Vertical distance in meters

    # Adjust coordinates to fit within warehouse dimensions
    x = min(max(x, 0), warehouse_width)    # Ensure x-coordinate is within [0, warehouse_width]
    y = min(max(y, 0), warehouse_height)   # Ensure y-coordinate is within [0, warehouse_height]

    return x, y, section

# Function to generate random DOA value between 0 and 180 degrees
def generate_random_doa():
    return random.uniform(0, 180)

# Function to generate timestamp with given timezone
def generate_timestamp(timezone):
    tz = pytz.timezone(timezone)
    timestamp = datetime.now(tz)
    return timestamp.strftime("%Y-%m-%d %H:%M:%S %Z%z")

# Function to determine tag location based on tag ID
def determine_tag_location(tag_id):
    # Generate random DOA value
    doa = generate_random_doa()

    # Calculate tag location based on generated DOA
    tag_location = calculate_tag_location(doa)
    timestamp = generate_timestamp('America/Denver')
    print("Tag with ID '{}' is located at: ({:.2f} m, {:.2f} m) with DOA {:.2f} degrees".format(tag_id, tag_location[0], tag_location[1], doa))
    print("Section:", tag_location[2])
    print("Timestamp:", timestamp)

# Example usage
tag_id = input("Enter the tag ID: ")  # Take tag ID as input
determine_tag_location(tag_id)

import matplotlib.pyplot as plt
import matplotlib.patches as patches

# Define parking lot dimensions
width = 120  # meters
height = 60  # meters

# Define margins
top_margin = 7
bottom_margin = 7
left_margin = 7
right_margin = 7

# Calculate inner rectangle dimensions
inner_width = width - left_margin - right_margin
inner_height = height - top_margin - bottom_margin

# Create figure and axis
fig, ax = plt.subplots()

# Draw outer rectangle
outer_rect = patches.Rectangle((0, 0), width, height, linewidth=1, edgecolor='r', facecolor='none')
ax.add_patch(outer_rect)

# Draw inner rectangle
inner_rect = patches.Rectangle((left_margin, bottom_margin), inner_width, inner_height, linewidth=1, edgecolor='b', facecolor='none')
ax.add_patch(inner_rect)

# Divide inner rectangle into 8 rows
row_heights = [5.6, 5.6, 6, 5.6, 5.6, 6, 5.6, 5.6]
row_widths = [inner_width / 42] * 42
current_height = bottom_margin
for i, (row_height, row_width) in enumerate(zip(row_heights, row_widths)):
    current_width = left_margin
    # Divide only specified rows into 42 columns
    if i in [0, 1, 3, 4, 6, 7]:
        for j in range(42):
            row_rect = patches.Rectangle((current_width, current_height), row_width, row_height, linewidth=1, edgecolor='g', facecolor='none')
            ax.add_patch(row_rect)
            current_width += row_width
    else:
        # Leave rows 3 and 6 with just one column
        row_rect = patches.Rectangle((left_margin, current_height), inner_width, row_height, linewidth=1, edgecolor='g', facecolor='none')
        ax.add_patch(row_rect)
    current_height += row_height

# Set axis limits and labels
ax.set_xlim(0, width)
ax.set_ylim(0, height)
ax.set_xlabel('Width (m)')
ax.set_ylabel('Height (m)')
ax.set_title('Parking Lot')

# Show plot
plt.gca().set_aspect('equal', adjustable='box')
plt.grid(True)
plt.show()

import random
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.patches as patches

class ParkingLot:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.total_spaces = 0
        self.available_spaces = 0
        self.parking_map = []  # Use strings instead of integers
        self.parking_table = pd.DataFrame(columns=["Car ID", "Parking Space"])
        self.calculate_spaces()

    def calculate_spaces(self):
        # Define margins
        top_margin = 7
        bottom_margin = 7
        left_margin = 7
        right_margin = 7

        # Calculate inner rectangle dimensions
        inner_width = self.width - left_margin - right_margin
        inner_height = self.height - top_margin - bottom_margin

        # Divide inner rectangle into 8 rows
        row_heights = [5.6, 5.6, 6, 5.6, 5.6, 6, 5.6, 5.6]
        row_widths = [inner_width / 42] * 42
        self.total_spaces = sum(row_widths) * len(row_heights)
        self.available_spaces = self.total_spaces
        current_height = bottom_margin
        for i, (row_height, row_width) in enumerate(zip(row_heights, row_widths)):
            current_width = left_margin
            for j in range(42):
                self.parking_map.append("")  # Initialize parking spaces
                current_width += row_width
            current_height += row_height

    def assign_parking_space(self, car_id):
        empty_spaces = [i for i, space in enumerate(self.parking_map) if space == ""]
        if not empty_spaces:
            print("Parking lot is full.")
            return -1
        else:
            parking_space = random.choice(empty_spaces)
            self.parking_map[parking_space] = car_id
            self.available_spaces -= 1
            self.parking_table.loc[len(self.parking_table)] = [car_id, parking_space]
            return parking_space

    def print_layout(self):
        # Reshape parking map to a grid
        rows = 8
        cols = 42
        occupancy_grid = [[1 if self.parking_map[i*cols + j] else 0 for j in range(cols)] for i in range(rows)]

        plt.figure(figsize=(15, 5))
        plt.imshow(occupancy_grid, cmap='binary', aspect='auto')
        plt.title('Parking Lot Layout')
        plt.xlabel('Parking Space')
        plt.ylabel('Row')
        plt.yticks(range(rows), [f"Row {i+1}" for i in range(rows)])
        plt.colorbar(label='Occupancy')
        plt.show()

def main():
    width = 120  # meters
    height = 60  # meters

    parking_lot = ParkingLot(width, height)

    while True:
        car_id = input("Enter car ID (type 'exit' to quit): ")
        if car_id.lower() == 'exit':
            break

        parking_space = parking_lot.assign_parking_space(car_id)

        if parking_space != -1:
            print(f"Car {car_id} parked at space {parking_space}")
        else:
            print("Parking failed.")

    parking_lot.print_layout()
    print("\nParking Table:")
    print(parking_lot.parking_table)

if __name__ == "__main__":
    main()

import matplotlib.pyplot as plt
import matplotlib.patches as patches
import random

class ParkingLot:
    def __init__(self):
        # Define parking lot dimensions
        self.width = 120  # meters
        self.height = 60  # meters

        # Define margins
        self.top_margin = 7
        self.bottom_margin = 7
        self.left_margin = 7
        self.right_margin = 7

        # Calculate inner rectangle dimensions
        self.inner_width = self.width - self.left_margin - self.right_margin
        self.inner_height = self.height - self.top_margin - self.bottom_margin

        # Initialize assigned parking spaces
        self.assigned_spaces = set()

        # Create figure and axis
        self.fig, self.ax = plt.subplots()

        # Draw outer rectangle
        self.outer_rect = patches.Rectangle((0, 0), self.width, self.height, linewidth=1, edgecolor='r', facecolor='none')
        self.ax.add_patch(self.outer_rect)

        # Draw inner rectangle
        self.inner_rect = patches.Rectangle((self.left_margin, self.bottom_margin), self.inner_width, self.inner_height, linewidth=1, edgecolor='b', facecolor='none')
        self.ax.add_patch(self.inner_rect)

        # Divide inner rectangle into rows
        self.row_heights = [5.6, 5.6, 6, 5.6, 5.6, 6, 5.6, 5.6]
        self.row_widths = [self.inner_width / 42] * 42
        self.current_height = self.bottom_margin
        for i, (row_height, row_width) in enumerate(zip(self.row_heights, self.row_widths)):
            self.current_width = self.left_margin
            # Divide only specified rows into 42 columns
            if i in [0, 1, 3, 4, 6, 7]:
                for j in range(42):
                    row_rect = patches.Rectangle((self.current_width, self.current_height), row_width, row_height, linewidth=1, edgecolor='g', facecolor='none')
                    self.ax.add_patch(row_rect)
                    self.current_width += row_width
            else:
                # Leave rows 3 and 6 with just one column
                row_rect = patches.Rectangle((self.left_margin, self.current_height), self.inner_width, row_height, linewidth=1, edgecolor='g', facecolor='none')
                self.ax.add_patch(row_rect)
            self.current_height += row_height

        # Set axis limits and labels
        self.ax.set_xlim(0, self.width)
        self.ax.set_ylim(0, self.height)
        self.ax.set_xlabel('Width (m)')
        self.ax.set_ylabel('Height (m)')
        self.ax.set_title('Parking Lot')

        # Show plot
        plt.gca().set_aspect('equal', adjustable='box')
        plt.grid(True)

    def assign_parking_space(self, car_id):
        # Get unassigned parking spaces
        unassigned_spaces = [i for i in range(1, 253) if i not in self.assigned_spaces]
        if not unassigned_spaces:
            print("Parking lot is full.")
            return -1
        else:
            # Randomly select a parking space
            selected_space = random.choice(unassigned_spaces)
            # Highlight the selected parking space
            row, col = divmod(selected_space - 1, 42)
            space_width = self.row_widths[col]
            space_height = self.row_heights[row]
            x = self.left_margin + col * space_width
            y = self.height - self.top_margin - (row + 1) * space_height
            selected_rect = patches.Rectangle((x, y), space_width, space_height, linewidth=2, edgecolor='orange', facecolor='none')
            self.ax.add_patch(selected_rect)
            self.fig.canvas.draw()
            # Update assigned spaces
            self.assigned_spaces.add(selected_space)
            return selected_space

# Example usage
parking_lot = ParkingLot()
car_id = input("Enter car ID: ")
parking_space = parking_lot.assign_parking_space(car_id)
if parking_space != -1:
    print(f"Car {car_id} parked at space {parking_space}")
